import os
import json
import shutil
import subprocess
from pathlib import Path

import click
import pandas as pd 

from .cli_config import *
from . import utils  as ul
from . import ChromHMM as ch



@click.group(cls=CustomMultiCommand, 
        context_settings=dict(help_option_names=['-h', '--help']))
def cli():
     pass


@cli.command()
@click.option('-o', '--output', required=True, help='metadata output path')
@click.option('-g', '--group', type=int, required=True, help="contrast groups, number")
@click.option('-repN', '--replicate', cls=OptionEatAll,type=tuple, help="replicate, number")
@click.option('-gn', '--group_name', cls=OptionEatAll, type=tuple, help="group name")
@click.option('-p1', cls=OptionEatAll,type=tuple, help="file path for  condtion 1")
@click.option('-p2', cls=OptionEatAll,type=tuple, help="file path for  condtion 2")
@click.option('-repN1', '--replicate1', cls=OptionEatAll,type=tuple, help="replicate1, number")
@click.option('-repN2', '--replicate2', cls=OptionEatAll,type=tuple, help="replicate2, number")
def meta(output, group, replicate, group_name, p1, p2, replicate1, replicate2):
    if not (pdir:= Path(output).parent).exists():
        print(f"{pdir} doest not exist")
        exit()
    output = Path(output).with_suffix(".csv")
    ul.meta_template(output, group, replicate, group_name,
                    p1, p2, repN1=replicate1, repN2=replicate2)


@cli.command(["lenCluster", "lc"], help="length cluster")
@click.option('-i', '--input', 'infile', type=click.Path(exists=True),
                required=True,  help='AS ioe file')
@click.option('-o', '--output', required=True, help="output path")
@click.option('-cl', '--custom_len', 'custom_len', cls=OptionEatAll, type=tuple, help="custom length")
@click.option('-nc', '--cluster', type=int, default=4, help="number of cluster")
@click.option('-bw', '--width', type=int, default=3, help="bin width")
@click.option('-lw', '--len_weight', type=float, default=2, help="length weight")
@click.option('--max_len', type=int, default=500, help="the max length of exon in clustering")
def len_cluster(infile, output, custom_len, cluster, width, len_weight, max_len):
    if not (pdir:= Path(output).parent).exists():
        print(f"{pdir} doest not exist")
        exit()                   
    ioe_df = pd.read_csv(infile, sep="\t")
    if "event_id" not in ioe_df.columns:
        print("file does not support!")
        exit()

    info_df = ul.extract_info(ioe_df)
    info_df["event_id"] = ioe_df["event_id"]
    output = Path(output).with_suffix(".png")
    if custom_len:
        lens = [int(i) for i in custom_len]
        df = ul.custome_cluster_len(info_df, output, lens, width=width, max_len=max_len)
    else:
        df = ul.cluster_len(info_df, output, n_cls=cluster, max_len=max_len, len_weight=len_weight, width=width)
    df.to_csv(Path(output).parent / f"{Path(output).stem}_cls_info.csv", index=False)


@cli.command(["lenPick", "lp"])
@click.option('-i', '--input', 'infile', type=click.Path(exists=True), help='AS ioe file')
@click.option('-o', '--output', help="output path")
@click.option('-rg', '--range', "len_range", type=(int, int), required=True, help="length range")
def len_pick(infile, output, len_range):
    if not (pdir:= Path(output).parent).exists():
        print(f"{pdir} doest not exist")
        exit()                   

    ioe_df = pd.read_csv(infile, sep="\t")
    info_df = ul.extract_info(ioe_df)
    info_df["event_id"] = ioe_df["event_id"]
    s, e = len_range
    pdf = info_df.loc[(s <= info_df["len"]) & ( info_df["len"] < e), :]
    pdf.to_csv(Path(output).parent / f"{Path(output).stem}_{s}-{e}", index=False)


as_type = ['SE', "A5", "A3", "MX", "RI", 'AF', 'AL']

@cli.command(["diffSplice", "ds"])
@click.option('-od', '--outdir', help="output directory")
@click.option('-md', '--metadata', type=click.Path(exists=True),
             help="contrast group metadata, generated by XXX")
@click.option('-gtf', '--gtf', type=click.Path(exists=True), help="gene annotation gtf file")
@click.option('-t', '--event_type', type=click.Choice(['all']+as_type),
             default="all", help="gene annotation gtf file")
@click.option('-m', '--method', type=click.Choice(['empirical', 'classical']),
             default="empirical", help="gene annotation gtf file")
@click.option('--exon_len', type=int, default=100,
             help="Defines the number of nucleotides to display in the output GTF. (Default: 100 nt)")
@click.option('--tpm_col', type=int, default=4, help="TPM columns index")
def diff_splice(outdir, metadata, gtf, event_type, exon_len, tpm_col, method):
    if event_type == "all":
        event_types = as_type
    else:
        event_types = [event_type]
    dsi = ul.DiffSplice(outdir, metadata, gtf, event_types, exon_len)
    dsi.ds(method)


@cli.command(["sigfilter", "sf"], help="filter significant result")
@click.option('-i', '--input', 'infile', type=click.Path(exists=True), help="dpsi file")
@click.option('-mi', '--meta_input', 'metadata', type=click.Path(exists=True), help="metadata file")
@click.option('-od', '--outdir', help="output directory")
@click.option('-dpsi', '--dpsi', type=float, default=0, help="dpsi")
@click.option('-p', '--pval', type=float, default=0.05, help="pval")
@click.option('-adpsi', '--abs_dpsi', type=float, default=0, help="absulte dpsi")
@click.option('-pf', '--psi_file', cls=OptionEatAll,type=tuple, help="psi files")
@click.option('-m', '--merge', is_flag=True, help="merge all to one file")
@click.option('-fmt', '--format', "fmt", type=click.Choice(['csv', 'tsv']), 
                default="tsv", help="out  file format ")
def sigfilter(infile, metadata, outdir, dpsi, pval, abs_dpsi, psi_file, merge, fmt):
    if infile:
        sf = ul.SigFilter(infile, outdir, dpsi, pval, abs_dpsi, psi_file, fmt)
        sf.run()
    if metadata:
        with open(metadata, "r") as f:
            meta_dic = json.load(f)
        
        for i in meta_dic:
            for at in meta_dic[i]["dpsi"].keys():
                infile = meta_dic[i]["dpsi"][at]
                psi_file1 = meta_dic[i]["control"]["psi"][at]
                psi_file2 = meta_dic[i]["treatment"]["psi"][at]
                psi_file = [psi_file1, psi_file2]
                sf = ul.SigFilter(infile, outdir, dpsi, pval, abs_dpsi, psi_file, fmt)
                sf.run()

@cli.command()
@click.option('-i', '--input', 'infiles',  cls=OptionEatAll, type=tuple, required=True, help="dpsi files")
@click.option('-o', '--outdir', default=".", help="outdir")
@click.option('-pval', '--pvalue', type=float, default=0.1, help="pvalue cutoff")
@click.option('-qval', '--qvalue', type=float, default=0.1, help="pvalue cutoff")
@click.option('-db', '--database', type=click.Choice(['GO', 'KEGG']), 
                default="GO", help="enrich database")
@click.option('-gene_id', '-gene_id', type=click.Choice(['ENSEMBL', 'ENTREZID', 'REFSEQ', 'SYMBOL']), 
                default="ENSEMBL", help="gene ID type")                      
@click.option('-orgdb', '--orgdb', required=True,
                help="OrgDb for GO annotation, such as: hs for Human, mm for Mouse. \
                    run 'astk ls -org' to view more ")
@click.option('-kegg_org', '--kegg_organism', 
                help="KEGG organism short alias.This is required if -db is KEGG.\
                    Organism list in http://www.genome.jp/kegg/catalog/org_list.html")          
def enrich(infiles, outdir, pvalue, qvalue, database, gene_id, orgdb, kegg_organism):
    rscript = Path(__file__).parent / "R" / "enrich.R"
    if not (org_db := ul.select_OrgDb(orgdb)):
        print(f"{orgdb} is wrong! Please run 'astk ls -org' to view more")
    if database == "KEGG":
        if not kegg_organism:
            print("Error: --kegg_organism is required!")
            exit()
    else:
        kegg_organism = "0"

    Path(outdir).mkdir(exist_ok=True)
    for file in infiles:
        out = Path(outdir) / Path(file).stem
        out.mkdir(exist_ok=True)
        params = [str(out), str(pvalue), str(qvalue), database,
                 gene_id, org_db , kegg_organism, file]
        info = subprocess.Popen(["Rscript", str(rscript), *params])
        if database == "KEGG" and not ul.check_kegg_RData(kegg_organism):
             info.wait()
    else:
        info.wait()


@cli.command(["enrichCompare", "ecmp"])
@click.option('-i', '--input', 'infiles',  cls=OptionEatAll, 
                required=True, type=tuple, help="dpsi files")
@click.option('-o', '--outdir', required=True, help="output directory")
@click.option('-cls', '--cluster', type=click.Path(exists=True),
                help="cluster information file")            
@click.option('-db', '--database', type=click.Choice(['GO', 'KEGG']), 
                default="GO", help="enrich database")
@click.option('-pval', '--pvalue', type=float, default=0.1, help="pvalue cutoff")
@click.option('-qval', '--qvalue', type=float, default=0.1, help="pvalue cutoff")
@click.option('-gene_id', '-gene_id', type=click.Choice(['ENSEMBL', 'ENTREZID', 'REFSEQ', 'SYMBOL']), 
                default="ENSEMBL", help="gene ID type")                      
@click.option('-orgdb', '--orgdb', required=True,
                help="OrgDb for GO annotation, such as: hs for Human, mm for Mouse. \
                    run 'astk ls -orgdb' to view more ")
@click.option('-kegg_org', '--kegg_organism', 
                help="KEGG organism short alias.This is required if -db is KEGG.\
                    Organism list in http://www.genome.jp/kegg/catalog/org_list.html")   
def enrich_cmp(infiles, outdir, cluster, database,
                pvalue, qvalue, gene_id, orgdb, kegg_organism):
    if not (org_db := ul.select_OrgDb(orgdb)):
        print(f"{orgdb} is wrong! Please run 'astk ls -orgdb' to view more")                
    if database == "KEGG" and not kegg_organism:
        print("Error: --kegg_organism is required!")
        exit()
    else:
        kegg_organism = "0"
    rscript = Path(__file__).parent / "R" / "enrichCompare.R"
    Path(outdir).mkdir(exist_ok=True)
    cluster = cluster if cluster else "0"
    params = [outdir, str(pvalue), str(qvalue), database,
              cluster, org_db, gene_id, kegg_organism, *infiles]
    info = subprocess.Popen(["Rscript", str(rscript), *params])
    info.wait()
    print(info)


@cli.command(["enrichLenCluster", "elc"])
@click.option('-i', '--input', 'infiles',  cls=OptionEatAll, 
                required=True, type=tuple, help="dpsi files")
@click.option('-o', '--outdir', required=True, help="output directory")
@click.option('-cls', '--cluster', type=click.Path(exists=True),
                required=True, help="cluster information file")
@click.option('-m', '--merge', is_flag=True, help="enrich with multiple merged files")              
@click.option('-db', '--database', type=click.Choice(['GO', 'KEGG']), 
                default="GO", help="enrich database")
@click.option('-pval', '--pvalue', type=float, default=0.1, help="pvalue cutoff")
@click.option('-qval', '--qvalue', type=float, default=0.1, help="pvalue cutoff")
@click.option('-gene_id', '-gene_id', type=click.Choice(['ENSEMBL', 'ENTREZID', 'REFSEQ', 'SYMBOL']), 
                default="ENSEMBL", help="gene ID type")                      
@click.option('-orgdb', '--orgdb', required=True,
                help="OrgDb for GO annotation, such as: hs for Human, mm for Mouse. \
                    run 'astk ls -orgdb' to view more ")
@click.option('-kegg_org', '--kegg_organism', 
                help="KEGG organism short alias.This is required if -db is KEGG.\
                    Organism list in http://www.genome.jp/kegg/catalog/org_list.html") 
def enrich_lc(infiles, outdir, cluster, merge, database, pvalue, qvalue,
              gene_id, orgdb, kegg_organism, ):
    if not (org_db := ul.select_OrgDb(orgdb)):
        print(f"{orgdb} is wrong! Please run 'astk ls -orgdb' to view more")                
    if database == "KEGG":
        if not kegg_organism:
            print("Error: --kegg_organism is required!")
            exit()
    else:
        kegg_organism = "0"
    rscript = Path(__file__).parent / "R" / "enrichLenCluster.R"
    Path(outdir).mkdir(exist_ok=True)
    merge = "1" if merge else "0"
    for file in infiles:
        params = [outdir, str(pvalue), str(qvalue), database, cluster,
                 org_db, gene_id, kegg_organism, file]
        info = subprocess.Popen(["Rscript", str(rscript), *params])
        if database == "KEGG" and not ul.check_kegg_RData(kegg_organism):
             info.wait() 
    else:
        if merge:
            params = [outdir, str(pvalue), str(qvalue), database, cluster,
                 org_db, gene_id, kegg_organism, *infiles]
            merge_info = subprocess.Popen(["Rscript", str(rscript), *params])
            merge_info.wait()
        else:
            info.wait()


@cli.command(["volcano", "vol"], help="Volcano plot analysis for dPSI")
@click.option('-i', '--input', "dpsi", cls=OptionEatAll, type=tuple, help="dpsi files")
@click.option('-o', '--outdir', type=click.Path(exists=True), help="output directory")
@click.option('-fmt', '--format', "fmt", type=click.Choice(['png', 'pdf']),
                 default="png", help="out figure format ")
def volcano(dpsi, outdir, fmt):
    rscript = Path(__file__).parent / "R" / "volcano.R"
    for f in dpsi:
        out = Path(outdir) / Path(f).with_suffix(f".volcano.{fmt}").name
        info = subprocess.Popen(["Rscript", str(rscript), f, out])
        info.wait()


@cli.command(help="PCA analysis for PSI")
@click.option('-i', '--input', 'infiles',  cls=OptionEatAll, 
                required=True, type=tuple, help="psi files")
@click.option('-o', '--output', 'outpath', required=True, help="figure output path")
@click.option('-fmt', '--format', "fmt", type=click.Choice(['png', 'pdf']),
                 default="png", help="out figure format ")
def pca(infiles, outpath, fmt):
    if not (pdir:= Path(outpath).parent).exists():
        print(f"{pdir} doest not exist")
        exit()
    rscript = Path(__file__).parent / "R" / "pca.R"
    outpath = Path(outpath).with_suffix(f".{fmt}")
    params = [str(outpath), *infiles]
    info = subprocess.Popen(["Rscript", str(rscript), *params])
    info.wait()


@cli.command(["heatmap", "hm"], help="Heatmap plot for PSI")
@click.option('-i', '--input', 'infiles',  cls=OptionEatAll, 
                required=True, type=tuple, help="psi files")
@click.option('-o', '--output', 'outpath', required=True, help="figure output path")
@click.option('-cls', '--cluster', type=click.Path(exists=True),
                help="cluster information file")     
@click.option('-fmt', '--format', "fmt", type=click.Choice(['png', 'pdf']),
                 default="png", help="out figure format ")
def heatmap(infiles, outpath, cluster, fmt):
    if not (pdir:= Path(outpath).parent).exists():
        print(f"{pdir} doest not exist")
        exit()
    rscript = Path(__file__).parent / "R" / "heatmap.R"
    cluster = cluster if cluster else "0"
    outpath = Path(outpath).with_suffix(f".{fmt}")
    params = [str(outpath), cluster, *infiles]
    info = subprocess.Popen(["Rscript", str(rscript), *params])
    info.wait()


@cli.command(help = "install R packages")
@click.option('-r', '--requirement', is_flag=True, help="install astk requirement R packages")
@click.option('-OrgDb', '--OrgDb', "OrgDb", help="install Genome wide annotation package")
@click.option('-cran', '--cran', help="install CRAN package")
@click.option('-bio', '--bioconductor', help="install Bioconductor package")
@click.option('-j', '--java',  is_flag=True, help="install java software")
def install(requirement, OrgDb, cran, bioconductor, java):
    rscript = Path(__file__).parent / "R" / "install.R"
    rq = "1" if requirement else "0"
    OrgDb = OrgDb if OrgDb else "0"
    cran = cran if cran else "0"
    bioconductor = bioconductor if bioconductor else "0"
    params = [rq, OrgDb, cran, bioconductor]
    info = subprocess.Popen(["Rscript", str(rscript), *params])
    info.wait()
    if java:
        print("install ChromHMM")
        ch.install(Path(__file__).parent)


@cli.command(["list", "ls"], help = "install R packages")
@click.option('-orgdb', '--OrgDb', "OrgDb",
                is_flag=True, help="list OrgDb")
def list(OrgDb):
    if OrgDb:
        for k, v in ul.OrgDb_dic.items():
            print(f"{k}: {v}")

@cli.command(help = "generate ChromHMM mark file")
@click.option('-o', '--output', required=True, help="file output path")
@click.option('-c', '--cell', cls=OptionEatAll, type=tuple, help="cell types")
@click.option('-m', '--mark', cls=OptionEatAll, type=tuple, help="mark names")
@click.option('-bed', '--bed', cls=OptionEatAll, type=tuple, help="bed files")
@click.option('-mn', '--markNum', cls=OptionEatAll, type=tuple, required=True,
                 help="mark count of every cell types") 
@click.option('-sep', help="split symbol for splitting bed file names") 
@click.option('-mi', "--markIndex", type=int, help="the mark index when bed files are splited by -sep symbol")
@click.option('--stacked', is_flag=True, 
            help="This flag replaces the mark entry with an entry of the form cell_mark.")
def mark(output, cell, mark, bed, marknum, sep, markindex, stacked):
    from itertools import chain

    if all([sep, markindex]):
        mark = [Path(i).stem.split(sep)[markindex-1] for i in bed]

    if len(mark) != len(bed):
        print("mark nmus dismatch bed files")
        exit()
    if len(cell) > 1 and marknum:
        cells = [i for i in chain(*[[cell[i]]*int(marknum[i]) for i in range(len(cell))])]
    elif len(cell) == 1:
        cells = [cell[0] for _ in bed]
    else:
        print("-mn/--markNum should be set when only one cell type")
        exit()
     
    if len(cells) != len(mark):
        print("-mn/--markNum is wrong")
        exit()

    if stacked:
        mark = [f"{cells[idx]}_{mark[idx]}" for idx in range(len(mark))]
        # cells = [f"genome" for _ in range(len(mark))]
    df = pd.DataFrame({
        "cell": cells,
        "mark": mark,
        "bed": bed
    })

    df.to_csv(output, sep="\t", index=False, header=False)


@cli.command(help = "generate ChromHMM anchor file")
@click.option('-i', '--input', 'infile', type=click.Path(exists=True), help="dpsi file")
@click.option('-o', '--output', required=True, help="file output path")
@click.option('-idx', '--index', type=int, help="element index")
@click.option('-si', '--sideIndex', type=(int, int), help="the center of two side index")
@click.option('-w', '--width', type=int, help="width")
@click.option('-rf', '--rightFlank', type=int, help="width of right flank")
@click.option('-lf', '--leftFlank', type=int, help="width of left flank")
def anchor(infile, output, index, sideindex, width, rightflank, leftflank):
    ch.gen_anchor_bed(infile, output, index, sideindex, width, rightflank, leftflank)


@cli.command(help = "generate bed file according to selected coordinates")
@click.option('-i', '--input', 'infile', type=click.Path(exists=True), help="dpsi file")
@click.option('-o', '--output', required=True, help="file output path")
@click.option('-s', '--start', type=int, help="start index of forward strand")
@click.option('-e', '--end', type=int, help="end index of forward strand")
@click.option('-rs', '--reverseStart', "r_start", type=int, help="start index of reverse strands")
@click.option('-re', '--reverseEnd', "r_end", type=int, help="end index of reverse strands")
def getcoor(infile, output, start, end, r_start, r_end):
    ul.get_coor_bed(infile, output, start, end, r_start, r_end)


CHROMSIZES_dir = Path(__file__).parent / "ChromHMM/CHROMSIZES"
genomes = [i.stem for i in CHROMSIZES_dir.glob("*.txt")]

@cli.command(["learnState", "lcs"], 
    help = "learns a chromatin state model, Wrapper of ChromHMM BinarizeBed and LearnModel")
@click.option('-n', "--numstates", default=2, type=int, help="states number")
@click.option('-id', '--indir', type=click.Path(exists=True), help="input directory of bed files")
@click.option('-mark', '--markfile', type=click.Path(exists=True), help="cell mark file")
@click.option('-bd', '--binaryDir', help="binary directory")
@click.option('-od', '--outdir',  help="output directory")
@click.option('-b', '--binsize', type=int, default=200 , help="binsize")
@click.option('-g', '--genome',  type=click.Choice(genomes), help="genome assembly")
@click.option('-mx', default="2400M", help="memory for java running")
@click.option('-p', "--processor", default=2, type=int, help="maxprocessors")
@click.option('-anchor', "--anchor", cls=OptionEatAll, type=tuple, default=(), help="anchor files")
@click.option('-coor', "--coor", cls=OptionEatAll, type=tuple, default=(), help="coordinate files")
@click.option('-nb', "--no_binary", is_flag=True, default=False, help="not run BinarizeBed")
@click.option('--stacked', is_flag=True, 
            help="This flag replaces the mark entry with an entry of the form cell_mark.")
def LearnState(numstates, indir, markfile, binarydir, outdir, binsize, 
                genome, mx, processor, anchor, coor, no_binary, stacked):
    ChromHMM_dir = Path(__file__).parent / "ChromHMM"
    ChromHMM_jar = ChromHMM_dir / "ChromHMM.jar"
    chrom_len = ChromHMM_dir / f"CHROMSIZES/{genome}.txt"

    if stacked:
        stacked_param = "-stacked"
    else:
        stacked_param = ""
    ChromHMM_cmd = f"java -mx{mx} -jar {ChromHMM_jar}"
    ChromHMM_bin = f"BinarizeBed {stacked_param} -peaks -b {binsize} {chrom_len} {indir} {markfile} {binarydir}"
    ChromHMM_lm = f"LearnModel -p {processor} -b {binsize} {binarydir} {outdir} {numstates} {genome}"
    if not no_binary:
        subprocess.call([*ChromHMM_cmd.split(), *ChromHMM_bin.split()])

    
    import uuid
    uid_str = f"{uuid.uuid4()}"
    for file in anchor:
        pfile = Path(file)
        if pfile.exists():
            tmp_name = f"{pfile.stem}.{uid_str}.tmp.bed{pfile.suffix}"
            shutil.copy(file, ChromHMM_dir / f"ANCHORFILES/{genome}/{tmp_name}")
        else:
            print(f"No such file or directory: {file}")
    for file in coor:
        pfile = Path(file)
        if pfile.exists():
            tmp_name = f"{pfile.stem}.{uid_str}.tmp.bed.{pfile.suffix}"
            shutil.copy(file, ChromHMM_dir / f"COORDS/{genome}/{tmp_name}")
        else:
            print(f"No such file or directory: {file}")

    subprocess.call([*ChromHMM_cmd.split(), *ChromHMM_lm.split()])

    for tfile in (ChromHMM_dir / f"ANCHORFILES/{genome}").glob(f"*{uid_str}.tmp*"):
        os.remove(tfile)
    for tfile in (ChromHMM_dir / f"COORDS/{genome}").glob(f"*{uid_str}.tmp*"):
        os.remove(tfile)


@cli.command(["motifEnrich", "me"], 
    help = "motif enrichment")
@click.option('-fa', "--fasta", cls=OptionEatAll, type=tuple, required=True, help="fasta files")
@click.option('-od', '--outdir', type=click.Path(), default=".", help="output directory")
@click.option('-mm', '--meme', type=click.Path(exists=True), required=True, help="path to .meme format file")
def motif_enrich(fasta, outdir, meme):
    Path(outdir).mkdir(exist_ok=True)

    rscript = Path(__file__).parent / "R" / "motifEnrich.R"
    params = [outdir, meme, *fasta]
    info = subprocess.Popen(["Rscript", str(rscript), *params])
    info.wait()


@cli.command(help="Gene Set Enrichment Analysis")
@click.option('-i', '--input', 'infile',  type=click.Path(exists=True), required=True, help="dpsi file")
@click.option('-od', '--outdir', default=".", help="outdir")
@click.option('-n', '--name', default="", help="output name prefix")
@click.option('-pval', '--pvalue', type=float, default=0.1, help="pvalue cutoff")
@click.option('-db', '--database', type=click.Choice(['GO', 'KEGG']), 
                default="GO", help="enrich database")
@click.option('-gt', '--geneType', type=click.Choice(['ENSEMBL', 'ENTREZID', 'REFSEQ', 'SYMBOL']), 
                default="ENSEMBL", help="gene ID type")                      
@click.option('-orgdb', '--orgdb', required=True,
                help="OrgDb for GO annotation, such as: hs for Human, mm for Mouse. \
                    run 'astk ls -org' to view more ")
@click.option('-kegg_org', '--kegg_organism', 
                help="required for kegg, KEGG organism short alias.This is required if -db is KEGG.\
                    Organism list in http://www.genome.jp/kegg/catalog/org_list.html")      
def gesa(infile, outdir, orgdb):
    rscript = Path(__file__).parent / "R" / "enrich.R"
    if not (org_db := ul.select_OrgDb(orgdb)):
        print(f"{orgdb} is wrong! Please run 'astk ls -org' to view more")
    if database == "KEGG":
        if not kegg_organism:
            print("Error: --kegg_organism is required!")
            exit()
    else:
        kegg_organism = "0"

    Path(outdir).mkdir(exist_ok=True)
    for file in infiles:
        out = Path(outdir) / Path(file).stem
        out.mkdir(exist_ok=True)
        params = [str(out), str(pvalue), str(qvalue), database,
                 gene_id, org_db , kegg_organism, file]
        info = subprocess.Popen(["Rscript", str(rscript), *params])
        if database == "KEGG" and not ul.check_kegg_RData(kegg_organism):
             info.wait()
    else:
        info.wait()
# event_type = ["SE", "SS", "MX", "RI", "FL"]
# gtf = "/home/public/genome/mm39_GRCm39/release_M27/gencode.vM27.annotation.gtf"
# pool_genes = True
# edge_exon_len = 100
# ioe_event(gtf, pool_genes, event_type, edge_exon_le n)




if __name__ == '__main__':
    cli()